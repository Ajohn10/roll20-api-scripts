{
  "name": "libTokenMarkers",
  "script": "libTokenMarkers.js",
  "version": "0.1.2",
  "description": "libTokenMarkers provides an easy encapsulation around Custom Token Markers.  It is a library for other scripts to use and does not have a user interface.  It is intended to be a dependency for other scripts.\r\n\r\n## Function Reference\r\n\r\n### `libTokenMarkers.getStatus( <arg> )` \r\n| Argument | Value       | \r\n| -------- | ------------|\r\n| arg      | string      |\r\n| [return] | TokenMarker | \r\n\r\nThis function will find the first TokenMarker with a **tag** or **name** of *arg* and return it.  Matches are case-insensitive.  In the case that there is not a matching TokenMarker, it will return an object that behaves like a TokenMarker, but is empty.\r\n\r\n```javascript\r\n    let status = libTokenMarker.getStatus( 'purple-dino' );\r\n```\r\n\r\n### `libTokenMarkers.getStatuses( <arg> )`\r\n| Argument | Value                | \r\n| -------- | -------------------- |\r\n| arg      | string               |\r\n| [return] | array of TokenMarker | \r\n\r\nThis function will find all the TokenMarkers with a **tag** or **name** of *arg* and return an array of all of them.  Matches are case-insensitive.  In the case that there are not any matching TokenMarkers, it will return an empty array.\r\n```javascript\r\n    let statuses = libTokenMarker.getStatuses( 'marked' );\r\n```\r\n\r\n\r\n### `libTokenMarkers.getOrderedList( )`\r\n| Argument | Value                | \r\n| -------- | ------               | \r\n| [return] | array of TokenMarker | \r\n\r\nThis function will return an array of all TokenMarkers, in the order they appear in the user interface.\r\n```javascript\r\n    let allStatuses = libTokenMarker.getOrderedList();\r\n```\r\n\r\n## TokenMarker Object Reference\r\n\r\nAll of the functions above return objects in the TokenMarker class hierarchy.  This provides a uniform interface to the four different types of status markers you might need to deal with:\r\n* Text -- the `dead` status and its red **X**\r\n* Color Dot -- the color statuses like `blue` and `pink`, and their non-image based visual\r\n* Legacy Markers -- the basic set like `archery-target` and `drink-me`, where the name and tag are the same\r\n* Custom Token Markers -- the new dynamic statuses with their images, names, and numbered tags\r\n\r\nThe TokenMarker object has 3 functions on it, detailed below.\r\n\r\n### `.getName()`\r\n| Argument | Value  | \r\n| -------- | ------ |\r\n| [return] | string | \r\n\r\nThis function returns the text name that was given to the status when it was created.\r\n\r\n### `.getTag()`\r\n| Argument | Value  | \r\n| -------- | ------ |\r\n| [return] | string | \r\n\r\nThis function returns the text tag that you use for setting it or checking if it is on a token.\r\n\r\n### `.getHTML( [scale], [css] )`\r\n| Argument           | Value                      | \r\n| --------           | ------                     | \r\n| scale *(optional)* | number (**Default:** 1.4 ) | \r\n| css *(optional)*   | css string                 | \r\n| [return]           | HTML string                | \r\n\r\nThis function returns a formatted HTML string which can be output in chat to display what the status looks like.  This is one of the main benefits of the TokenMarker object.  The `scale` parameter can be used to adjust the size of the visual with respect to the text that surrounds it.  Generally, you won't need to supply a parameter as the output will be scaled with the text it is associated with:\r\n```javascript\r\n    let tm = libTokenMarkers.getStatus('blue');\r\n    sendChat('',`<p>Blue at nomral size: ${tm.getHTML()}<\/p>`);\r\n    sendChat('',`<h1>Blue at title size: ${tm.getHTML()}<\/h1>`);\r\n```\r\n\r\n### `.applyTo(...tokens)`\r\n| Argument | Value  | \r\n| -------- | ------ |\r\n| tokens   | Roll20 token object, objects, or array of objects | \r\n\r\nThis function places this Token Marker on each token supplied to the function.  You can supply a Roll20 Token object, or multiple parameters that are Roll20 Token objects, or arrays of Roll20 Token objects.\r\n```javascript\r\n    let tm = libTokenMarkers.getStatus('blue');\r\n    tm.applyTo(token1, token2);\r\n    tm.applyTo(tokenArray);\r\n```\r\n\r\n### `.applyWithNumberTo(number, ...tokens)`\r\n| Argument | Value  | \r\n| -------- | ------ |\r\n| number   | an integer between 0 and 9 |\r\n| tokens   | Roll20 token object, objects, or array of objects | \r\n\r\nThis function places this Token Marker, with the supplied number assigned to it, on each token supplied to the function.  The Number must be the first argument, then you can supply a Roll20 Token object, or multiple parameters that are Roll20 Token objects, or arrays of Roll20 Token objects.\r\n```javascript\r\n    let tm = libTokenMarkers.getStatus('blue');\r\n    tm.applyTo(3, token1, token2);\r\n    tm.applyTo(7, tokenArray);\r\n```\r\n\r\n### `.removeFrom(...tokens)`\r\n| Argument | Value  | \r\n| -------- | ------ |\r\n| tokens   | Roll20 token object, objects, or array of objects | \r\n\r\nThis function removes the Token Marker on each token supplied to the function.  You can supply a Roll20 Token object, or multiple parameters that are Roll20 Token objects, or arrays of Roll20 Token objects.\r\n```javascript\r\n    let tm = libTokenMarkers.getStatus('blue');\r\n    tm.removeFrom(token1, token2);\r\n    tm.removeFrom(tokenArray);\r\n```\r\n\r\n\r\n## Example Script\r\n\r\n```javascript\r\n\/* global libTokenMarkers *\/\r\non('ready', ()=>{\r\n\r\n\t\/\/ Make sure libTokenMarkers exists, and has the functions that are expected\r\n\tif('undefined' === typeof libTokenMarkers\r\n\t\t|| (['getStatus','getStatuses','getOrderedList'].find(k=>\r\n\t\t\t!libTokenMarkers.hasOwnProperty(k) || 'function' !== typeof libTokenMarkers[k]\r\n\t\t))\r\n\t) { \r\n\t\t\/\/ notify of the missing library\r\n\t\tsendChat('',`\/w gm <div style=\"color:red;font-weight:bold;border:2px solid red;background-color:black;border-radius:1em;padding:1em;\">Missing dependency: libTokenMarkers<\/div>`);\r\n\t} else {\r\n\r\n\t\t\/\/ active code\r\n\t\ton('chat:message',(msg) => {\r\n\r\n\t\t\tif('api'===msg.type && \/^!test-ltm\/i.test(msg.content)){\r\n\r\n\t\t\t\tlet tokens = (msg.selected || [])\r\n\t\t\t\t\t.map(o=>getObj('graphic',o._id))\r\n\t\t\t\t\t.filter(g=>undefined !== g)\r\n\t\t\t\t\t;\r\n\r\n\t\t\t\tlet all = libTokenMarkers.getOrderedList();\r\n\t\t\t\tlet statLast = all[all.length-1];\r\n\t\t\t\tlet statGreen = libTokenMarkers.getStatuses('green');\r\n\r\n\t\t\t\tlet statBlue = libTokenMarkers.getStatus('BlUe');\r\n\r\n\t\t\t\tsendChat('',`<div>Found ${all.length} statuses.<\/div>`);\r\n\t\t\t\tsendChat('',`<div>Last one is named \"${statLast.getName()}\" with tag \"${statLast.getTag()}\" and looks like ${statLast.getHTML(3)}.<\/div>`);\r\n\r\n\t\t\t\tsendChat('',`<div>There are ${statGreen.length} statuses named green: ${statGreen.map(s=>s.getHTML(1,\"border:1px solid green;padding: .1em; border-radius: .3em; margin: .2em;\")).join('')}<\/div>`);\r\n\t\t\t\tsendChat('',`<div>Looked up \"${statBlue.getName()}\" with \"BlUe\", looks like ${statBlue.getHTML(3)}.<\/div>`);\r\n\r\n\t\t\t\tlet nope = libTokenMarkers.getStatus('asdfasdfasdafsd');\r\n\t\t\t\tlet nopes = libTokenMarkers.getStatuses('asdfasdfasdafsd');\r\n\t\t\t\tsendChat('',`<div>Looked up \"asdfasdfasdfasdf\", found name: \"${nope.getName()}\", tag: \"${nope.getTag()}\", image: ${nope.getHTML()}<\/div>`);\r\n\t\t\t\tsendChat('',`<div>There are ${nopes.length} statuses named \"asdfasdfasdfasdf\".<\/div>`);\r\n\r\n\t\t\t\tsendChat('',`<div><h3>All Statuses<\/h3><table style=\"border:1px solid #999;padding:.2em;\"><thead><tr><th style=\"padding: 1px .1em;\">Icon<\/th><th style=\"padding: 1px .1em;\">Name<\/th><th style=\"padding: 1px .1em;\">Tag<\/th><\/tr><\/thead><tbody>${\r\n\t\t\t\t\tall.map((s,n)=>`<tr style=\"background-color:${n%2?'#fff':'#ccc'}\"><td style=\"padding: 1px .1em;\">${s.getHTML()}<\/td><td style=\"padding: 1px .1em;\">${s.getName()}<\/td><td style=\"padding: 1px .1em;\">${s.getTag()}<\/td><\/tr>`).join('')\r\n\t\t\t\t}<\/tbody><\/table><\/div>`);\r\n\t\t\t\t\r\n\t\t\t\tstatGreen[0].applyTo(tokens);\r\n\t\t\t\tsetTimeout(()=>{\r\n\t\t\t\t\tstatGreen[0].removeFrom([tokens]);\r\n\t\t\t\t},5000);\r\n\r\n\t\t\t\tstatBlue.applyWithNumberTo(5,tokens[0]);\r\n\t\t\t\tsetTimeout(()=>{\r\n\t\t\t\t\tstatBlue.applyWithNumberTo(3,tokens[0]);\r\n\t\t\t\t},3000);\r\n\r\n\t\t\t\tsetTimeout(()=>{\r\n\t\t\t\t\tstatBlue.removeFrom(tokens[0]);\r\n\t\t\t\t},8000);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n});\r\n```\r\n",
  "authors": "The Aaron",
  "roll20userid": "104025",
  "patreon": "https://www.patreon.com/shdwjk",
  "useroptions": {},
  "dependencies": {},
  "modifies": {
    "state.libTokenMarkers": "read,write"
  },
  "conflicts": []
}
